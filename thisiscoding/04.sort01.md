# 정렬 알고리즘
* 정렬 : 데이터를 특정한 기준에 따라 순서대로 나열하는 것



## 선택 정렬 알고리즘
* 처리되지 않은 데이터 중에서 가장 작은 데이터를 선택해 맨 앞에 있는 데이터와 바꾸는 것을 반복한다.
* 예시 ) 7 5 9 0 3 1 6 2 4 8
    + 가장 작은 값 0 > 0 | 5 9 7 3 1 6 2 4 8
    + 가장 작은 값 1 > 0 1 | 9 7 3 5 6 2 4 8
    + 가장 작은 값 2 > 0 1 2 | 7 3 5 6 9 4 8
    + 반복 >>> 0 1 2 3 4 5 6 7 8 | 9 
    + 맨 마지막 데이터는 정렬을 하지 않아도 가장 큰 값이 뒤로 가 있다.

```python
array = [7,5,9,0,3,1,6,2,4,8]

for i in range(len(array)) :
    min_index = i # 가장 작은 원소의 인덱스를 구한다.
    for j in range(i+1, len(array)) :
        if array[min_index] > array[j] :
            min_index = j
    array[i], array[min_index] = array[min_index], array[i] # 스와프

print(array)
```
* 선택 정렬의 시간 복잡도
    + O(N^2)
    + N번 만큼 가장 작은 수를 찾아서 맨 앞으로 보내야 한다.
    + N + (N-1) + (N-2) + ... + 2
    + (N^2 + N - 2) / 2 


## 삽입 정렬 알고리즘
* 처리되지 않은 데이터를 하나씩 골라 적절한 위치에 삽입
* 선택 정렬에 비해 더 빠르게 구현
* 맨 앞에 있는 데이터가 이미 정렬되어 있다고 가정하고 두 번쩨 데이터가 정렬된 데이터에 어디에 들어가는 것이 좋은지 판단한다.
* 예시 ) 7 5 9 0 3 1 6 2 4 8
    + 7 | 5 9 0 3 1 6 2 4 8
    + 5 7 | 9 0 3 1 6 2 4 8
    + 5 7 9 | 0 3 1 6 2 4 8
    + 0 5 7 9 | 3 1 6 2 4 8
    + 반복 0 1 2 3 4 5 6 7 8 9

```python
array = [7,5,9,0,3,1,6,2,4,8]

for i in range(1, len(array)) :
    for j in range(i, 0, -1) : # 인덱스 i 부터 1까지 1씩 감소하면서 반복
        if array[j] < array[j-1] :  # 비교하면서 한 칸씩 왼쪽으로 이동함
            array[j], array[j-1] = array[j-1], array[j]
        else :  # 자기보다 작은 데이터를 만다면 그 위치에서 멈춤
            break

print(array)
```
* 삽입 정렬의 시간 복잡도
    + O(N^2)
    + 현재 리스트의 데이터가 거의 정렬되어 있는 상태라면 매우 빠르게 동작함 -> 최선의 경우 O(N) 시간 복잡도를 가짐


## 퀵 정렬
* 기준 데이터를 설정하고 그 기준보다 큰 데이터와 작은 데이터의 위치를 바꾸는 방법
* 가장 많이 사용되는 정렬 알고리즘
* 첫 번째 데이터를 기준 데이터(Pivot)로 설정함
* 예시 ) 5 7 9 0 3 1 6 2 4 8
    + 현재 피벗 : 5, 왼쪽부터 피봇 데이터보다 큰 값을 선택, 오른쪽부터 5보다 작은 값을 선택
    + 5 ***7*** 9 0 3 1 6 2 ***4*** 8
    + 5 4 ***9*** 0 3 1 6 ***2*** 7 8
    + 5 4 2 0 3 ***1*** ***6*** 9 7 8 : 왼쪽에서 온 데이터와 오른쪽에서 온 데이터의 위치가 바뀐다.
    + 가장 작은 값과 피봇 값을 바꾼다.
    + 1 4 2 0 3 ***5*** 6 9 7 8
    + 피봇 값을 기준으로 왼쪽 데이터끼리 퀵 정렬, 오른쪽 데이터끼리 퀵 정렬을 한다.
    + 1 ***4*** 2 ***0*** 3 | 5 | ***6*** ***9*** 7 8
    + 1 0 2 4 3 | 5 | 6 9 7 8
* 이상적인 경우 분할이 절반씩 일어난다면 전체 연산 횟수로 O(NlogN)을 기대할 수 있음
* 퀵 정렬의 시간 복잡도
    + O(NlogN)
    + 하지만 최악의 경우 O(N^2)의 시간 복잡도를 가질 수 있다.

```python
array = [5,7,9,0,3,1,6,2,4,8]

def quick_sort(array, start, end) :
    if start >= end :   # 원소가 1개인 경우 종료
        return
    pivot = start       # 첫 번째 원소를 피벗이라고 정한다.
    left = start + 1    # 왼쪽에서부터
    right = end         # 오른쪽에서부터
    while(left <= right) :  # 오른쪽과 왼쪽이 교차할 때까지 반복
        # 피벗보다 큰 데이터를 찾을 때까지 반복
        while(left <= end and array[left] <= array[pivot]) :
            left += 1
        # 피벗보다 작은 데이터를 찾을 때까지 반복
        while(right > start and array[right] >= array[pivot]) : 
            right -= 1
        if (left > right) : # 왼쪽과 오른쪽이 엇갈렸다면 작은 데이터와 피벗을 교체 
            array[right], array[pivot] = array[pivot], array[right]
        else :  # 엇갈리지 않았다면 작은 데이터와 큰 데이터를 교체
            array[left], array[right] = array[right], array[left]
    # 분할 이후 왼쪽 부분과 오른쪽 부분에서 각각 정렬 수행
    quick_sort(array, start, right-1)
    quick_sort(array, right+1, end)

quick_sort(array, 0, len(array)-1)
print(array)
```
* 파이썬의 장점을 살린 방식

```python
array = [5,7,9,0,3,1,6,2,4,8]

def quick_sort2(array) :
    # 원소가 1개인 경우 종료
    if len(array) <= 1 :
        return array

    pivot = array[0]    # 피벗은 첫 번째 원소
    tail = array[1:]    # 피벗을 제외한 리스트

    left_side = [x for x in tail if x <= pivot] # 분할된 왼쪽 부분
    right_side = [x for x in tail if x > pivot] # 분할된 오른쪽 부분

    # 분할 이후 왼쪽 부분과 오른쪽 부분에서 각각 정렬 수행, 전체 리스트 반환
    return quick_sort(left_side) + [pivot] + quick_sort[right_side]

print(quick_sort(array))
```



## 계수 정렬
* 특정한 조건이 부합할 때만 사용할 수 있지만 매우 빠르게 동작하는 정렬 알고리즘
* 데이터의 크기 범위가 제한되어 정수 형태로 표현할 수 있을 때 사용 가능함
* 데이터의 개수가 N, 데이터 (양수) 중 최댓값이 K일 때 최악의 경우에도 수행시간 O(N+K)를 보장합니다.
* 예시 ) 7 5 9 0 3 1 6 2 9 1 4 8 0 5 2
    + 가장 작은 데이터부터 가장 큰 데이터까지의 범위가 모두 담길 수 있도록 리스트를 생성한다.
    + 각각의 데이터가 몇 번 등장하는 지 count 한다.


    |인덱스| 0 1 2 3 4 5 6 7 8 9 |
    |---|---|
    |계수(count)| 0 0 0 0 0 0 0 0 0 0 |
    + count한 결과, 각 데이터가 몇 번씩 등장했는지 구할 수 있다.

    |인덱스| 0 1 2 3 4 5 6 7 8 9 |
    |---|---|
    |계수(count)| 2 2 2 1 1 2 1 1 1 2 |
    + 리스트의 첫 번째 데이터부터 하나씩 그 값만큼 반복하여 인덱스를 출력합니다.
        + 출력결과 : 0 0 1 1 2 2 3 4 5 5 6 7 8 9 9

```python
# 모든 원소의 값이 0보다 크거나 같다고 가정
array = [7, 5, 9, 0, 3, 1, 6, 2, 9, 1, 4, 8, 0, 5, 2]
# 모든 범위를 포함하는 리스트 선언 (모든 값은 0으로 초기화)
count = [0] * (max(array) + 1)

for i in range(len(array)) :
    count[array[i]] += 1    # 각 데이터에 해당하는 인덱스의 값 증가

for i in range(len(count)) :    # 리스트에 정렬된 정보 확인
    for j in range(count[i]) :
        print(i, end='')    # 횟수만큼 인덱스 출력
``` 
* 계수 정렬 시간 , 공간 복잡도
    + O(N+K)
    + 계수 정렬은 때에 따라서 심각한 비효율성을 초래할 수 있다. (예, 0과 999,999 단 두 개의 데이터만 있을 때)
    + 동일한 값을 가지는 데이터가 여러 개 등장할 때 효과적으로 사용할 수 있다.



|정렬 알고리즘|평균 시간 복잡도|공간 복잡도|특징
|---|---|---|---|
|선택정렬|O(N^2)|O(N)|아이디어가 간단하다.|
|삽입정렬|O(N^2)|O(N)|데이터가 거의 정렬되어 있을 때는 가장 빠르다.|
|퀵 정렬|O(NlogN)|O(N)|대부분의 경우에 가장 적합, 충분히 빠르다.|
|계수정렬|O(N+K)|O(N+K)|데이터의 크기가 한정되어 있는 겨웅에만 사용 가능, 빠르게 동작함|
